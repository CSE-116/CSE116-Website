{% extends 'hw/hw.html' %}

{% block title %}CSE116: Task 3{% endblock %}

{% block header %}
    <h1>Coding Task 4 - Binary Trees</h1>
    <hr/>
    <h5>Time Estimate: 14 hours</h5>
    <hr/>
{% endblock %}

{% block task %}

    <div class="card-header section-testing">
        <div>Requirements</div>
    </div>

    <div class="section-card card-testing hw-content">

        <hr/>


        <h3>
            Project Structure
        </h3>

        <hr/>
        <p>
            You will continue to add functionality to your existing project from the previous task. There is
            no new repository to clone.
        </p>

        <hr/>
        <h3>Specification</h3>
        <hr/>

        <p>
            In this task, you will implement the following specs. Once all of these are complete, your enemies will have
            an AI that allows them to make complex decisions based on their surrounding environment.
        </p>
        <ul>
           <li>
              <code>Player</code> - Invincibility Frames (<code>app.gameengine.model.gameobjects.Player</code>)
              <ul>
                 <li>
                    In game development, invincibility frames are a short period of time when players become immune to
                    taking damage. They're used to prevent players from constantly taking damage every frame from the
                    same source without having the opportunity to escape danger. In this part of the task, you will
                    implement invincibility frames for the players so that enemies can now deal the proper amount of damage.
                 </li>
                 <li>
                    Add an instance variable of type double to the Player class representing the amount of time
                    they are immune from damage. This should be initialized to 0.
                 </li>
                 <li>
                    Override the <code>takeDamage</code> method from the DynamicGameObject class. Your overridden method should first
                    check if the player has more than 0 invincibility time left. If so, the method should do nothing. If
                    the player doesn't have any invincibility time left, you should have the Player take damage as normal,
                    then reset the amount of invincibility time left to 0.5.
                    <ul>
                       <li>
                          If no damage is being done (i.e. damage is 0 or negative), don't modify the invincibility time.
                       </li>
                       <li>
                          You can call the superclass' <code>takeDamage</code> method by calling <code>super.takeDamage</code>.
                       </li>
                    </ul>
                 </li>
                 <li>
                    Override the <code>update()</code> method from the GameObject class. Your overridden method should begin
                    with a call to the superclass' update method, then it should subtract the invincibility time
                    by the change in time (dt).
                    <ul>
                       <li>If the player already has 0 invincibility time left, it should be left as 0.</li>
                    </ul>
                 </li>
              </ul>
           </li>

           <li>
              <code>Enemy</code> - Dealing Damage And Moving Path (<code>app.games.topdownobjects.Enemy</code>)
              <ul>
                 <li>
                    <ul>
                       <li>
                          Modify the existing overridden <code>collideWithDynamicObject</code> method to deal
                          damage to the player rather than destroying them.
                       </li>
                       <li>The amount of damage dealt should be equal to the enemy's strength instance variable.</li>
                    </ul>
                 </li>
                 <li>
                    <ul>
                       <li>
                          Move the instance variable for the enemy's path you made in task 2 into
                          <code>DynamicGameObject</code>, along with the getter <code>getPath</code> and setter
                          <code>setPath</code>. Since Enemy extends DynamicGameObject, this should not have any affect
                          on the game because of the power of inheritance. Make sure you leave the Enemy's update
                          method, this will be moved later on in this task.
                       </li>
                     </ul>
                 </li>
              </ul>
           </li>


        </ul>

        <p>
           Now, you should be able to run into enemies and watch your health go down in the UI without instantly
           being reset to the beginning of the level.
        </p>

        <ul>
           <li><p><code>Decision</code> (<code>app.gameengine.model.ai</code>)</p>
              <ul>
                 <li>In the <code>ai</code> package, create a new class named <code>Decision</code></li>
                 <li>
                    Create a getter and setter <code>getName</code> and <code>setName</code> where name is a string.
                    This name will be used when debugging your decision tree.
                 </li>
                 <li>Create a constructor that takes a String as a parameter and sets the decision's name.</li>
                 <li>
                    Create a method named <code>decide</code> that returns a boolean and takes in a reference to a
                    <code>DynamicGameObject</code>, <code>Level</code>, and a <code>double</code> dt (in this exact
                    order!). This method should be blank initially (just return false). You will be overriding this
                    method using inheritance.
                 </li>
                 <li>
                    Create a method named <code>doAction</code> that returns void and takes in a reference to a
                    <code>DynamicGameObject</code>, <code>Level</code>, and a <code>double</code> dt (again, in this
                    exact order). This method should again be blank, it will be overridden using inheritance.
                 </li>
              </ul>
           </li>
           <li><p><code>DecisionTree</code> (<code>app.gameengine.model.ai</code>)</p>
              <ul>
                 <li>In the <code>ai</code> package, create a new class named <code>DecisionTree</code></li>
                 <li>
                    Create an instance variable of type <code>BinaryTreeNode&lt;Decision&gt;</code> and create a getter
                    <code>getTree</code> and a setter <code>setTree</code> for that instance variable.
                 </li>
                 <li>
                    Create a method <code>traverse</code> that returns a reference to a <code>Decision</code> and takes
                    a <code>DynamicGameObject</code>, <code>Level</code>, and <code>double</code> dt as parameters (In
                    that order).
                    <ul>
                       <li>
                          This method will traverse through the tree, making decisions to go left or right by calling
                          <code>decide</code> on the value of each tree node. A value of true should make the tree
                          travel right, and a value of false should make the tree travel left. When a leaf node is
                          reached, the inner <code>Decision</code> value should be returned. If no leaf node is reached,
                          the method should return null instead.
                       </li> 
                    </ul> 
                 </li>
                 <li>
                    Create a method <code>reverse</code> that returns void and takes a reference to a
                    <code>BinaryTree&lt;Decision&gt;</code> as a parameter
                    <ul>
                       <li>
                          This method will reverse the binary tree, switching the left and right nodes all the way down
                          the tree. TODO: add example.
                       </li>
                    </ul>
                 </li>
                 <li>
                    Create a method <code>reverse</code> that returns void and takes no parameters. This
                    method should simply call the previously mentioned reverse method with the
                    root node of the tree as a parameter.
                 </li>
              </ul>
           </li>
           <li>Decision child classes (<code>app.gameengine.model.ai</code>)
              <ul>
                 <li>
                    You will write the following classes in the <code>ai</code> package. While the amount of classes
                    here seems daunting, each class, ignoring all the imports and class declaration boilerplate, should
                    only have 1-4 lines of code; You need not overthink this.
                 </li>
                 <li>
                    Decisions will be written such that they <strong>only override <em>one</em> of decide/doAction</strong>. 
                    The nodes that override doAction will be placed in your tree as leaf nodes, and the nodes that
                    override decide will be placed in your tree with two child nodes. This will allow us to give
                    enemies complex behavior based on their surroundings.
                    <ul>
                       <li><code>LowHP</code>
                          <ul>
                             <li>
                                Create the <code>LowHP</code> class that extends <code>Decision</code>. Add a
                                constructor that takes in a String for the name (so that the super constructor may be
                                called) and a double representing the HP percentage this node should use to determine if
                                the enemy is on low HP. You should make an instance variable to store this percentage.
                             </li>
                             <li>
                                 This will override <code>decide</code> and return true if the enemies health is &lt;
                                 the node's percentage (use your instance variable here, the instance variable should
                                 have a range of 0.0 to 1.0) of it&#39;s maximum health and false otherwise.
                             </li>
                          </ul>
                       </li>
                       <li><code>NearPlayer</code> 
                          <ul>
                             <li>
                                Create the <code>NearPlayer</code> class that extends <code>Decision</code>. Add a
                                constructor that takes in a String for the name (so that the super constructor may be
                                called) and a double representing the acceptable distance that this node should use. You
                                should make an instance variable to store this distance.
                             </li>
                             <li>
                                 This will override the <code>decide</code> method and return true if the distance
                                 between itself and the player is &lt; the acceptable distance instance variable and
                                 false otherwise. (Hint: use the Pythagorean theorem/Euclidean Distance to determine
                                 distance!)
                             </li>
                          </ul>
                       </li>
                       <li><code>MaxHP</code>
                          <ul>
                             <li>
                                Create the <code>MaxHP</code> class that extends <code>Decision</code>. This will override
                                the <code>decide</code> method and return true if the enemies health is at its
                                maximum.
                             </li>
                          </ul>
                       </li>
                       <li><code>MoveTowardPlayer</code>
                          <ul>
                             <li>
                                Create the <code>MoveTowardPlayer</code> class that extends <code>Decision</code> This
                                will override the <code>doAction</code> method and should move towards the player.
                                (Hint: you should move all your <code>update</code> code in enemy from task 2 to this
                                method)
                             </li>
                          </ul>
                       </li>
                       <li><code>Heal</code><ul>
                             <li>
                                Create the <code>Heal</code> class that extends <code>Decision</code>. Add a
                                constructor that takes in a String for the name (so that the super constructor may be
                                called) and a double representing the amount to heal by each frame. You
                                should make an instance variable to store this amount.
                             </li>
                             <li>
                                 This will override the <code>doAction</code> method and should set the enemies velocity
                                 to 0 and heal by their instance variable * dt. (TODO: It may be cool to change their
                                 sprite while the enemy is healing, perhaps we could have the constructor also accept a
                                 file name and a spritesheet column so that they can change the sprite while it's
                                 healing. However, there isn't really a cool healing sprite in the game. I would like to
                                 have them add some visual healing indication though)
                             </li>
                          </ul>
                       </li>
                       <li><code>ShootPlayer</code><ul>
                             <li>
                                DEPRECATED--Figure out some other action that would be good in the
                                current game.
                                (TODO!!!!!!!!!!!!!! someone suggest something, shooting works ig but the original plan
                                was to do some projectile stuff in task 3 so they'd be familiar with it, but this is no
                                longer the case.)
                             </li>
                          </ul>
                       </li>
                    </ul>
                 </li>
              </ul>
           </li>
           <li> <code>Enemy</code> - DecisionTree implementation
              <ul>
                 <li>
                    Now that you have implemented your decision tree, you can implement it into your game! You should
                    give enemy a <code>DecisionTree</code> instance variable, along with a getter
                    <code>getDecisionTree</code> and a setter <code>setDecisionTree</code>. In your enemies constructor,
                    you can set the decision tree to whatever you would like.
                    <ul>
                       <li>
                          Feel free to get creative! Experiment around, try to come up with interesting behaviors for
                          enemies. Keep an eye out on piazza, because we will be sharing some DecisionTrees and
                          Decisions of our own that you can add to your game.
                       </li>
                    </ul>
                 </li>
              </ul>
           </li>
        </ul>



        <p>
        Note: You can see feedback in Autolab for your tests without completing the
        programming portion of
        this task, but you must at least create every clas/method from this specification. You can "stub
        out"
        these methods by having them always return a fixed value, but they must exist so the grading code,
        and your tests, can compile and run.
        </p>

        <br/>
        <hr/>
        <h3>Testing Utilities</h3>
        <hr/>

        <p>
           You will write a static method <code>compareDecisionTree</code> that returns void and takes two
           <code>BinaryTreeNode&lt;Decision&gt;</code>s as parameters. This method should fail a junit assert if the two
           trees are not equal and do nothing if they are equal. You should compare the inner <code>Decision</code>
           value's <code>getName</code> to check for equality.
        </p>

        <br/>
        <hr/>
        <h3>
           Testing Object
        </h3>
        <hr/>

        <p>
           If you would like, you may create a new class in your <code>tests</code> package that extends
           <code>Decision</code>. You can override whatever you need to in your testing to give this object the behavior
           you want. The point of this object is to make your testing easier so you can use asserts on just the object
           rather than testing on enemies.
        </p>

        <p>
           It is recommended that you override the constructor to give your testing object some additional state. You
           can then use this additional state in your <code>decide</code> method to determine whether or not you should
           go left or right. (TODO: is the wording for this ok? lmk if it can be improved)
        </p>

        <p>
         This is not required and will not be tested on autolab, but it is recommended that you do this. It will make
         your testing significantly easier.
        </p>

        <br/>
        <hr/>
        <h3>
           Testing Requirements
        </h3>
        <hr/>

        <p>Create a class named <code>TestTask4</code> in the <code>tests</code> package.</p>


        <p>You will write tests for the following functionality from the specification:</p>

        <ul>
           <li>
              <code>DecisionTree</code>
              <ul>
                 <li>
                    <code>traverse</code> & <code>reverse</code>
                 </li>
              </ul>
           </li>
        </ul>

        <p>
         While you are not required to use your testing utility and test object, it is very highly recommended. They
         will make your life considerably easier.
        </p>

        <br/>
        <hr/>
        <h3>
           Programming Requirements
        </h3>
        <hr/>

        <p>
        Implement all the functionality from the specification.
        </p>


        <br/>
        <hr/>
        <h3>Autolab Feedback</h3>
        <hr/>

        <p>
        The feedback in Autolab will be given in 3 phases. If you don't complete a phase, then feedback for
        the following phase(s) will not be provided.
        </p>

        <ol>
           <li>Running your tests on a correct solution
              <ul>
                 <li>Your tests will be run against a solution that is known to be correct. If your tests do
                    not pass this correct solution, there is an error somewhere in your tests that must be
                    fixed
                    before you can move on with the assignment. If your tests don't get past this check, you
                    should re-read this document and make sure you implemented your tests and code according
                    the specification. You should also make sure that if there are multiple correct outputs
                    to the input in your tests cases that you accept any of the outputs as correct
                 </li>
              </ul>
           </li>
           <li>Checking your tests for feature coverage
              <ul>
                 <li>
                    The next phase is to check if your tests check for a variety of features defined by
                    different inputs. You should write at least one test case for each feature to pass this
                    phase
                 </li>
                 <li>
                    Passing this phase does not necessarily mean that your testing is completely thorough.
                    Satisfying Autolab is the bare minimum testing requirement. Not all possible inputs are
                    checked, and it is sometimes possible to pass this phase
                    with weak testing. If you are struggling to earn credit for code that you believe
                    is correct, you should write more than the required tests
                 </li>
              </ul>
           </li>
           <li>Running my tests on your solution
              <ul>
                 <li>
                    Once Autolab is happy with your tests, it will run my tests against your code to check
                    it for correctness. If your testing is thorough, and your code passes your tests, then
                    you should pass this phase. If you pass your tests, but fail one of mine, it is an
                    indicator that you should write more tests to help expose your bug
                 </li>
              </ul>
           </li>
        </ol>

        <p>
        Once you complete all 3 phases, you will have completed this Task and Autolab will confirm this
        with a score of 1.0 for complete.
        </p>
    </div>
    {% endblock %}
