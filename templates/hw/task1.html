{% extends 'hw/hw.html' %}

{% block title %}CSE116: Task 1{% endblock %}

{% block header %}
    <h1>Coding Task 1</h1>
    <hr/>
    <h5>Time Estimate: 5 hours</h5>
    <hr/>
{% endblock %}

{% block task %}

    <div class="card-header section-testing">
        <div>Requirements</div>
    </div>

    <div class="section-card card-testing hw-content">

        <hr/>
        <h3>
            Project Structure
        </h3>
        <hr/>

        <p>
            GitHub Repository link: <a href="">TBD</a>
        </p>
        <ol>
            <li>Clone the starter code from the repository into a new IntelliJ project</li>
            <li>Make sure the src folder is marked as the source root (Right click the src
                folder, choose “mark directory as” and choose sources root)
            </li>
        </ol>
        <p>
            Once you have the project opened in IntelliJ, you'll see a src folder which contains a folder another folder called main, which contains another folder called java.
            Inside this folder is the Java package app which contains all the code for the project. The starter code contains
            many Java classes needed for the engine to run, which can be ignored for the time being.
        </p>
        <p>
            For this task, you will be writing code in the following classes:
        </p>
        <ul>
            <li><code>DynamicGameObject</code>, located in the package <code>app.gameengine.model.gameobjects</code></li>
            <li><code>Wall</code>, located in the package <code>app.games.topdown</code></li>
            <li><code>PhysicsEngine</code>, located in the package <code>app.gameengine.model.physics</code></li>
            <li><code>TestTask1</code>, located in the package <code>app.tests</code></li>
        </ul>
        <p>
            You will also need to use the provided <code>Vector2D</code> and <code>Hitbox</code> classes from the <code>app.gameengine.model.physics</code>
            package for this task. These classes will not be modified.
        </p>
        <p>
            To submit your project, create a zip file containing your entire project and
            submit it to Autolab. (Click file -> export -> Project to Zip File, though there may be
            slight differences to this across OSes and versions). If this option is not available, you may need to install
            the "Android" plugin through the settings menu
        </p>

        <br/>
        <hr/>

        <h3>
            Specification
        </h3>

        <hr/>

        <p>In this task, you will test and implement the following specs:</p>

        <p>
            Note: All methods are public and non-static, unless otherwise noted, from this point forward in the
            course.
        </p>

        <ul>
            <li><code>DynamicGameObject</code>
                <ul>
                    <li>Modify the DynamicGameObject constructor to initialize instance variables for the following:
                        <ul>
                            <li>An int representing the Max HP of the object.</li>
                            <li>An int representing the current HP of the object. Initially, this should be set to the object's Max HP.</li>
                            <li>A Vector2D (from the physics package) representing the velocity of the object. This should be initialized to x = 0.0, y = 0.0.</li>
                            <li>A Vector2D representing the orientation the object is facing. This should be initialized to x = 0.0, y = 1.0.</li>
                            <li>Note: the given constructor initializes the location using inheritance, with super(location). You are not expected to fully understand this (yet), and should not modify it</li>
                        </ul>
                    </li>
                    <li>Implement the following getters and setters for the instance variables:
                        <ul>
                            <li><code>getHP</code></li>
                            <li><code>setHP</code>
                                <ul>
                                    <li>HP cannot exceed Max HP. If the parameter exceeds MaxHP, HP should be set to the maximum</li>
                                </ul>
                            </li>
                            <li><code>getMaxHP</code></li>
                            <li><code>getVelocity</code></li>
                            <li><code>getOrientation</code></li>
                        </ul>
                    </li>
                    <li>Implement a method named <code>takeDamage()</code> that takes in an int. This method should
                        subtract the current HP instance variable by the amount specified in the parameter.
                        <ul>
                            <li>If the parameter is negative, this method should do nothing.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><code>Wall</code>
                <ul>
                    <li>Write a method called <code>collideWithDynamicObject</code> that takes in a (reference to a)
                        <code>DynamicGameObject</code> and returns void. This method should modify the state of the
                        DynamicGameObject such that it cannot pass through the wall.
                        <ul>
                            <li>
                                This method should not modify the velocity of the intersecting object, only its position
                            </li>
                            <li>Note: along with the getter for velocity, you can also call <code>getLocation</code>
                            to access the location vector (coordinates) of a DynamicGameObject. You do not need to write
                                this method; you can access it through inheritance.
                            </li>
                            <li>
                                While you don't have a setVelocity/setLocation method, you can modify the values of a
                                Vector2D using the <code>setX</code> and <code>setY</code> methods in the Vector2D class.
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><code>PhysicsEngine</code>
                <ul>
                    <li>Implement a method called <code>updateObject</code> that takes in a DynamicGameObject and a double representing the change in time. This method
                    should update the position vector of the DynamicGameObject based on the value of its velocity vector.
                        <ul>
                            <li>Note: the change in distance (for both components of the vector) is equal to
                                the velocity (of that direction) multiplied by the change in time.</li>
                        </ul>
                    </li>
                    <li>Implement a method called <code>detectCollision</code> that takes in two Hitboxes and returns a boolean. The boolean
                        should return true if the two Hitboxes are colliding and false otherwise.
                        <ul>
                            <li>In order to prevent clipping, these collisions should account for some imprecision.</li>
                        </ul>
                    </li>
                    <li>
                        Implement a method called <code>updateLevel</code> that takes in a Level and a double representing
                        the change in time. This method should update all DynamicGameObjects contained within the level and
                        process all collisions in the level.
                        <ul>
                            <li>You don't need to fully understand the Level class for this task. The methods
                                <code>getDynamicObjects</code> and <code>getStaticObjects</code> in the level class return
                            ArrayLists containing all the respective objects in the level which will be useful for this method</li>
                            <li>Collisions can be between StaticGameObjects and DynamicGameObjects. If a collision is detected,
                                it should call the respective <code>collideWithStaticObject</code> or <code>collideWithDynamicObject</code>
                                methods on the two objects</li>
                            <li>You should use the previous methods written in <code>PhysicsEngine</code> for this one.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <br/>
        <hr/>

        <h3>Testing Utilities</h3>
      <hr/>


      <p>
         Testing utilities are methods to assist you with writing thorough and clean tests, which you will write in many of the remaining tasks.
         This utility should be written in the <code>TestTask1</code> class in the tests package.
      </p>


      <ul>
         <li><code>comparePlayers</code> - Write a method named <code>comparePlayers</code>
            in the tests.TestTask1 class that:
            <ul>
               <li>
                  Takes [references to] 2 Player objects as parameters
               </li>
               <li>
                  Checks if the two Player objects contain all the instance variable values, including location,
                  velocity, orientation, HP, and maxHP. The method fails a JUnit
                  assert if any of these variables do not have the same values
               </li>
               <li>
                  Note: For any variables that are stored as Vector2D objects, you must check both their X and Y components
               </li>
            </ul>
         </li>

      </ul>

      <p>Note: You still have to create every class and method from the specification before getting feedback on your
        submission in Autolab since the grader will not be able to compile if those classes/methods do not
         exist. You don't have to implement them yet, and they can all return a default value</p>


      <br/>
      <hr/>

        <h3>
            Testing Requirements
        </h3>

        <hr/>
        <p>
            You will write JUnit tests for the following methods in the specification:
        </p>

        <ul>
            <li><code>DynamicGameObject</code>
                <ul>
                    <li><code>DynamicGameObject</code></li>
                        <ul>
                            <li>
                                You should test that each of the instance variables is correctly set by the constructor
                            </li>
                            <li>
                                This includes location, velocity, orientation, maxHP, and hp
                            </li>
                        </ul>
                    <li><code>setHP</code></li>
                    <li><code>takeDamage</code></li>
                    <li>
                        Note: DynamicGameObjects cannot be instantiated directly. When testing these methods, you should
                        use Player objects, which will have access to these methods due to inheritance. You do not need to
                        understand this (yet)
                    </li>
                </ul>
            </li>
            <li><code>Wall</code>
                <ul>
                    <li>
                        You DO NOT need to test the <code>collideWithDynamicObject</code> method. Tests are provided for you 
                        in the TestTask1 class, which you may use to help you write the method itself
                    </li>
                </ul>
            </li>
            <li><code>PhysicsEngine</code>
                <ul>
                    <li><code>updateObject</code></li>
                    <li><code>detectCollision</code></li>
                </ul>
            </li>
        </ul>


        <br/>
        <hr/>

        <h3>
            Programming Requirements
        </h3>

        <hr/>
        <p>
            Implement the methods from the specification.
        </p>


        <br/>
        <hr/>

        <h3>Autolab Feedback</h3>

        <hr/>
        <p>
            The feedback in Autolab will be given in 3 phases. If you don't complete a phase, then feedback for
            the following phase(s) will not be given.
        </p>

        <ol>
            <li>Running your tests on a correct solution
                <ul>
                    <li>Your tests will be run against a solution that is known to be correct. If your tests do
                        not pass this correct solution, there is an error somewhere in your tests that must be
                        fixed
                        before you can move on with the assignment. If your tests don't get past this check, you
                        should re-read this document and make sure you implemented your tests and code according
                        the specification. You should also make sure that if there are multiple correct outputs
                        to the input in your tests cases that you accept any of the outputs as correct.
                    </li>
                </ul>
            </li>
            <li>Checking your tests for feature coverage
                <ul>
                    <li>
                        The next phase is to check if your tests check for a variety of features defined by
                        different inputs. You should write at least one test case for each feature to pass this
                        phase.
                    </li>
                    <li>
                        Passing this phase does not necessarily mean that your testing is completely thorough.
                        Satisfying Autolab is the bare minimum testing requirement. Not all possible inputs are
                        checked and it is sometimes possible to pass this phase
                        with weak testing. If you are struggling to earn credit for code that you believe
                        is correct, you should write more than the required tests
                    </li>
                </ul>
            </li>
            <li>Running my tests on your solution
                <ul>
                    <li>
                        Once Autolab is happy with your tests, it will run my tests against your code to check
                        it for correctness. If your testing is thorough, and your code passes your tests, then
                        you should pass this phase. If you pass your tests, but fail one of mine, it is an
                        indicator that you should write more tests to help expose your bug.
                    </li>
                </ul>
            </li>
        </ol>

        <p>
            Once you complete all 3 phases, you will have completed this Task and Autolab will confirm this
            with a score of 1.0 for complete.
        </p>
    </div>
{% endblock %}
