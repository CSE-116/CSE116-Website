{% extends 'hw/hw.html' %}

{% block title %}CSE116: Task 2{% endblock %}

{% block header %}
    <h1>Coding Task 2</h1>
    <hr/>
    <h5>Time Estimate: </h5>
    <hr/>
{% endblock %}

{% block task %}

    <div class="card-header section-testing">
        <div>Requirements</div>
    </div>

    <div class="section-card card-testing hw-content">

        <hr/>


        <h3>
            Project Structure
        </h3>

        <hr/>
        <p>
            You will continue to add functionality to your existing project from the previous task. There is
            no new repository to clone.
        </p>

        <p>
            For this task, you will be writing code in the following classes:
        </p>
        <ul>
            <li><code>SampleTopDownGame</code>, located in the package <code>app.games</code></li>
            <li><code>Enemy</code>, located in the package <code>app.games.topdownobjects</code></li>
        </ul>
        <p>
            You will also need to create new classes in these exact locations:
        </p>
        <ul>
            <li><code>Pathfinding</code>, in the package <code>app.gameengine.model.ai</code></li>
            <li><code>TestTask2</code>, in the package <code>tests</code></li>
        </ul>
        <p>
            You will also be using the provided <code>LinkedListNode</code> class from the <code>app.gameengine.model.datastructures</code>
            package. You <i>may</i> find it helpful to add to this class, however you <b>cannot modify or remove any of the given code</b>.
            You can use these additions in your implementation, but not in your tests (the TestTask2 class).
        </p>
        <br/>
        <hr/>
        <h3>Specification</h3>
        <hr/>

        <p>In this task, you will test and implement the following specs:</p>

        <ul>
            <li><code>SampleTopDownGame</code> - Linked List Operations
                <ul>
                    <li>
                        Currently, the way the game handles loading levels is poorly implemented.
                        The first part of this task will be to improve it using Linked Lists. The following
                        methods that will be implemented should interact with a LinkedListNode of Level instance
                        variable you will add to the <code>SampleTopDownGame</code> class.
                    </li>
                    <li>
                        Add a getter called <code>getLevelList</code>. This method should return the LinkedListNode of
                        type Level representing the head of the list of Levels.
                        <ul>
                            <li>If no Levels have been added, this method should return <code>null</code>.</li>
                        </ul>
                    </li>
                    <li>
                        Add a setter called <code>setLevelList</code> that takes in a LinkedListNode of Levels and
                        returns void.
                        <ul>
                            <li>This method should replace the instance variable representing the head of the list with
                            the LinkedListNode in the parameter.</li>
                        </ul>
                    </li>
                    <li>
                        Add a method called <code>addLevel</code> that takes in a Level
                        as a parameter and returns void.
                        <ul>
                            <li>
                                This method should append the Level specified in the parameter to the Linked List
                                of levels.
                            </li>
                        </ul>
                    </li>
                    <li>
                        Add a method called <code>removeLevelByName</code> that takes in a String and returns void.
                        <ul>
                            <li>This method should remove the level with the specified name String from the Linked List of levels.</li>
                            <li>If multiple Levels exist with this name, it should only remove the first one.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><code>SampleTopDownGame</code> - Modifications
                <ul>
                    <li>
                        Now that the Linked List operations have been implemented, you will now make the following
                        modifications to the given methods:
                        <ul>
                            <li>
                                Replace the body of the <code>advanceLevel</code> method to use the Linked List
                                operations. When this method is called, it should advance the head of the Level
                                list to the next node, then call <code>loadLevel</code> on the level contained
                                at the (new) head of the Linked List.
                                <ul><li>If the path is <code>null</code>, this method should do nothing.</li></ul>
                            </li>
                            <li>
                                Modify the <code>init</code> method to add the three given levels to the Linked List
                                before the given <code>loadLevel</code> call.
                            </li>
                        </ul>
                    </li>
                    <li>With these changes, you should be able to play through the game as before.</li>
                </ul>
            </li>
            <li><code>Enemy</code> - Path Operations
                <ul>
                    <li>
                        You will now implement some path operations to the Enemy class.


                        Once this is complete, Enemies will
                        be able to create and follow paths in game, which will be represented by a LinkedListNode of
                        Vector2D objects.
                    </li>
                    <li>
                        Add a method called <code>setPath</code> that takes in a LinkedListNode of Vector2D objects.
                        This method should set an instance variable representing the Enemy's path being followed.
                    </li>
                    <li>
                        Add a method called <code>getPath</code> that returns a LinkedListNode of Vector2D objects.
                        This method should return the instance variable representing the Enemy's path.
                    </li>
                </ul>
            </li>
            <li><code>Pathfinding</code> - <code>findPath</code> method
                <ul>
                    <li>
                        In the <code>Pathfinding</code> class you created, write a <strong>static</strong> method
                        called <code>findPath</code> that takes in two Vector2D objects as parameters and returns a
                        LinkedListNode of Vector2Ds.
                    </li>
                    <li>
                        This method should return the shortest valid path that takes it from the
                        <strong>tile containing</strong> the first Vector2D object to the
                        <strong>tile containing</strong> the location of the second Vector2D object.
                        <ul>
                            <li>
                                A path is valid if each Vector2D object after the head of the list is one tile
                                above, below, to the left, or to the right of the previous one AND if each Vector2D
                                object in the list is aligned to a tile (i.e. no decimals).
                                <ul>
                                    <li>[(3.0, 4.0), (3.0, 5.0), (4.0, 5.0)] is valid.</li>
                                    <li>[(3.0, 4.0), (3.0, 5.0), (5.0, 6.0)] is not valid as the third Vector2D is two tiles right of the second.</li>
                                    <li>[(3.0, 4.0), (4.0, 5.0), (4.0, 6.0)] is not valid as the second Vector2D is diagonal
                                    to the first one.</li>
                                    <li>[(3.1, 4.9), (3.1, 5.9), (4.1, 5.9)] is not valid as it is not aligned to a tile.</li>
                                </ul>
                            </li>
                            <li>
                                This is NOT the same as starting from the location of the first Vector2D and
                                ending at the location of the second Vector2D.
                            </li>
                            <li>
                                You may find it helpful to review the overview of the coordinate system
                                in the task 1 handout.
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><code>Enemy</code> - Path Functionality
                <ul>
                    <li>
                        Finally, modify the given method <code>update</code> so that it has the following behavior:
                        <ul>
                            <li>
                                If the Enemy's path LinkedListNode is <code>null</code>, it should use the <code>findPath</code> method
                                from the <code>Pathfinding</code> class to generate a path from the Enemy's location to the Level's Player's
                                location. This path should then be assigned to the enemy.
                            </li>
                            <li>
                                If the Enemy is within a small amount of the location at the path's head, the Enemy's
                                position should be set to exactly that location. The head of the list should then be moved
                                one node further in the list.
                                <ul>
                                    <li>This is necessary to prevent enemies from getting caught at the edge of a hitbox.</li>
                                </ul>
                            </li>
                            <li>
                                Otherwise, the Enemy's velocity should be set to move towards the tile at the head of the
                                Enemy's path.
                                <ul>
                                    <li>The Enemy's velocity should have a magnitude (speed) of <code>2.0</code>.</li>
                                    <li>Since the Enemy can only move in four directions, only one component of
                                        a moving Enemy's velocity will be non-zero at any point.</li>
                                    <li>If the enemy is already at that tile, it should move the path's head node up one further in the list.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <p>
            Note: You can see feedback in Autolab for your testing utilities and tests without completing the
            programming portion of
            this task, but you must at least create the classes and methods that you test. You can "stub out"
            these methods by having them always return a fixed value, but they must exist so the grading code,
            and your tests, can compile and run.
        </p>

        <br/>
        <hr/>
        <h3>Testing Utilities</h3>
        <hr/>

        <p>
            Create a class named TestTask2 in the tests package and write the
            following methods in that class (Note: Do not add the @Test annotation to these methods since they
            are not tests):
        </p>

        <ul>
            <li><code>compareListsOfLevels</code> - Write a method named compareListsOfLevels in the tests.TestDataStructures1 class that:
                <ul>
                    <li>
                        Takes [references to] 2 LinkedListNode&lt;Level&gt; objects as parameters and  returns void
                    </li>
                    <li>
                        This method checks if the names of all Levels in both lists are the same and are in the same order.
                        The method fails a JUnit assert if the lists do not contain all the same names of their Level
                        objects in the same order
                    </li>
                    <li>
                        Note that you cannot use == or .equals to compare 2 Levels. You must specifically check the
                        name values.
                    </li>
                </ul>
            </li>
            <li>
                <code>validatePath</code> - Write a method named <code>validatePath</code> that:
                <ul>
                    <li>
                        takes in a LinkedListNode of Vector2D objects and returns void.
                    </li>
                    <li>
                        This method should fail a JUnit assert if the path from the parameter is invalid.
                    </li>
                    <li>
                        This should use the same criteria as the <code>findPath</code> method uses.
                    </li>
                </ul>
            </li>
        </ul>

        <br/>
        <hr/>
        <h3>
            Testing Requirements
        </h3>
        <hr/>

        <p>
            Add test methods to the tests.TestTask2 class, using the @Test annotation, that tests the
            following methods from the specification:
        </p>

        <ul>
            <li>
                <code>SampleTopDownGame</code> class:
                <ul>
                    <li><code>addLevel</code></li>
                    <li><code>removeLevelByName</code></li>
                    <li><code>advanceLevel</code></li>
                    <li>
                        For these tests, you should call the TopDownLevel constructor whenever a Level object
                        needs to be initialized.
                    </li>
                    <li>
                        Also, make sure your tests account for the behavior of the given SampleTopDownGame constructor.
                    </li>
                </ul>
            </li>
            <li>
                <code>Pathfinding</code> class:
                <ul>
                    <li><code>findPath</code></li>
                </ul>
            </li>
        </ul>
        <p>
            You should call your testing utility methods to save time while
            writing these tests.
        </p>

        <br/>
        <hr/>
        <h3>
            Programming Requirements
        </h3>
        <hr/>

        <p>
            Implement the functionality from the specification.
        </p>


        <br/>
        <hr/>
        <h3>Autolab Feedback</h3>
        <hr/>

        <p>
            The feedback in Autolab will be given in 4 phases. If you don't complete a phase, then feedback for
            the following phase(s) will not be provided.
        </p>

        <ol>
            <li>Testing your testing utility methods
                <ul>
                    <li>
                        Each of your testing utility methods will be checked with a variety of test cases to ensure that
                        they make all the required checks. This phase will ensure that your utility methods are accurate
                        before you start using them in your tests
                    </li>
                </ul>
            </li>
            <li>Running your tests on a correct solution
                <ul>
                    <li>Your tests will be run against a solution that is known to be correct. If your tests do
                        not pass this correct solution, there is an error somewhere in your tests that must be
                        fixed
                        before you can move on with the assignment. If your tests don't get past this check, you
                        should re-read this document and make sure you implemented your tests and code according
                        the specification. You should also make sure that if there are multiple correct outputs
                        to the input in your tests cases that you accept any of the outputs as correct
                    </li>
                </ul>
            </li>
            <li>Checking your tests for feature coverage
                <ul>
                    <li>
                        The next phase is to check if your tests check for a variety of features defined by
                        different inputs. You should write at least one test case for each feature to pass this
                        phase
                    </li>
                    <li>
                        Passing this phase does not necessarily mean that your testing is completely thorough.
                        Satisfying Autolab is the bare minimum testing requirement. Not all possible inputs are
                        checked, and it is sometimes possible to pass this phase
                        with weak testing. If you are struggling to earn credit for code that you believe
                        is correct, you should write more than the required tests
                    </li>
                </ul>
            </li>
            <li>Running my tests on your solution
                <ul>
                    <li>
                        Once Autolab is happy with your tests, it will run my tests against your code to check
                        it for correctness. If your testing is thorough, and your code passes your tests, then
                        you should pass this phase. If you pass your tests, but fail one of mine, it is an
                        indicator that you should write more tests to help expose your bug
                    </li>
                </ul>
            </li>
        </ol>

        <p>
            Once you complete all 4 phases, you will have completed this Task and Autolab will confirm this
            with a score of 1.0 for complete.
        </p>
    </div>
{% endblock %}
